Group members (same group as project 1):
Molly Fawcett
Shehzeen Syed
Ethan Kocses

We ran xv6 through both WSL on Windows and directly on Ubuntu. xv6 was installed as detailed in project 0, except with a compiler downgrade.

The screenshots seen in the ticks_run, simple_scheduler, and advanced_scheduler folders were taken on an Ubuntu system running an Intel i7 12700k CPU.

We decided on the stride and lottery schedulers because these seemed like the schedulers that would have the most similar implementations. We essentially tried to follow what we learned in class about these schedulers, but there's naturally more to consider in a real OS environment. We thought about things like gaming, losing track of ticks due to non timer interrupts, and other similar things but found that many of these things were likely out of scope. One thing we considered with our stride scheduler was bumping sleeping processes up to the minimum pass value of currently runnable processes when they become runnable. This could be important since sleeping processes coming in isn't too different from a new process being created in the way that it could monopolize the CPU. Although, we weren't sure if this was doing too much for the project and we just kind of ran out of time to do it. We do recognize though that this is something a real stride scheduler would likely do. Ultimately, We did a lot of manual tests with our schedulers by adding print statements within the scheduler logic and while it's very difficult to track what's going on a lot of the time, we found that our implementations worked as expected from what we could gather.

For our get_random function (which we used both to generate the tickets for processes in stride and the winner in lottery), we basically copied xv6's rand function defined in usertests.c and added functionality to keep the random numbers within the input bounds. Although this PRNG is determinitic based on the seed that is hardcoded into proc.c, it seemed to give random enough results while still varying depending on how and when different processes were created/scheduled. This seed can be changed manually in the code for different results.

For the testing seen in the screenshots, the ticks_run_test.c, cpu_load_test.c, and basic_scheduler_tests.c files were created. The ticks_run_test.c just tests the ticks_run syscall by having the program loop a large number of times then making the call. cpu_load_test.c forks into a child, which then forks into a grandchild, and they all do tons of loops competing for the CPU. This is where you can see some variationv between the schedulers because the execution time for each process changed depending on the number of tickets it gets. It's especially easy to see in this program because they all want the CPU at all times and they all last a long time, unlike something like stressfs that gives up the CPU often. Finally, basic_scheduler_tests.c is used to just make sure the schedulers work under basic workloads (more advanced workloads can be seen in schedulertest.c, which is used to generate the results of the metrics report) and is used on both stride and lottery. It forks and execs into cpu_load_test, stressfs, find, and cat README | uniq, and prints out relevant info about what it runs. It also tests the syscalls we created for these schedulers to make sure they work. We created other test files as well, but these were mostly just for our own use while we were figuring out the project, so they can be ignored.